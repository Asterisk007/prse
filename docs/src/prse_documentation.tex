% Document setup
\documentclass[letterpaper, 12pt]{article}
\addtolength{\oddsidemargin}{-.875in}
\addtolength{\evensidemargin}{-.875in}
\addtolength{\textwidth}{1.75in}
\addtolength{\topmargin}{-.875in}
\addtolength{\textheight}{1.75in}
% Adding a blank page command
\def\blankpage{%
      \clearpage%
      \thispagestyle{empty}%
      \addtocounter{page}{-1}%
      \null%
      \clearpage}
% Packages to include
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage[document]{ragged2e}
\usepackage{hyperref}
\hypersetup{
   colorlinks = true,
   linkcolor = {blue}
}
\usepackage{mathtools}
\usepackage{tabularx}
\usepackage{makecell}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{wrapfig}
\usepackage{caption}
\usepackage{graphicx}
% New commands
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\R}{\mathbb{R}}
\definecolor{darkgreen}{RGB}{0, 145, 39}

\renewcommand\theadfont{\bfseries}
\lstset{
   frame=tb,
   language=C++,
   aboveskip=3mm,
   belowskip=3mm,
   columns=flexible,
   basicstyle={\small\ttfamily},
   numbers=none,
   numberstyle=\tiny\color{gray},
   keywordstyle=\color{blue},
   commentstyle=\color{darkgreen},
   stringstyle=\color{purple},
   breaklines=true,
   breakatwhitespace=true,
   tabsize=3
}

\graphicspath{ {./images/} }
% Document start
\begin{document}
\title{\underline{PRSE}\\ A Programming Language for Tired C++ Developers}
\author{Written by Daniel Ellingson\\with advice and support from Dr. Todd Gibson}
\date{Compiled from {\LaTeX} source on \today}
\maketitle

\newpage

\begin{figure}
   \begin{center}
      \vspace*{-8cm}
      \includegraphics{logo}
   \end{center}
\end{figure}
\clearpage

\newpage

\tableofcontents

\newpage

\section{Preface}
\subsection{Acknowledgements}
Many thanks to Dr. Todd Gibson for approaching me and offering his guidance and support in creating
this language. Many more to my mother, who had to listen to me talk endlessly about some of the finer
details I would focus on for the language, and offerred an ear for it all despite holding little interest
in the topic itself.
\subsection{Conventions of this documentation}
Throughout this book, we will use different stylizations to indicate different parts of text.\linebreak

A line starting with a dollar sign (`\$') indicates a command you should type into a terminal emulator, such as bash, Windows CMD, or PowerShell:
\begin{lstlisting}
    \$ prsec
\end{lstlisting}

This is unique from a code block, which we will start and end with the lines ``\texttt{//-----snip-----}''.
The `\texttt{snip}' in this case indicates a snippet of code, which may or may not compile on its own.
\begin{lstlisting}
    //-----snip-----
    /*
        A block of code, which demonstrates some feature or multiple features of the language.
    */
    //-----snip-----
\end{lstlisting}

\section{Introduction}
Having spent four years of my life learning C++ and various other programming languages, I feel that
it is within my level of experience to say that most C-like languages fail to do everything the best
way. C may have its syntax, and C++ may have its classes, and other languages may have their own
features which make them useful for their given paradigm---but I wish for a language that has the
syntax I {\em prefer}. Enter PRSE.\linebreak

PRSE has features that most other C-like languages have, with a few extra goodies on the side for
those who may tire of repeated code.

\begin{itemize}
\item C\#-/Java-style classes, for those who think header files are outdated
\item Python-style dictionaries, for those who like JSON. Yes, we have both JSON and actual classes.
   Both are handy, I assure you
\item R-style vectorization: that is, items in an array or in an STL vector can be quickly iterated
   over. More in \hyperref[sec:flowcontrol-loops]{flow control - loops}
\end{itemize}

PRSE code compilation is a two-step process: PRSE code is read in and checked for any potential
errors and (assuming none are found) translates that code into C++ which it then subsequently
compiles into the actual binary (unless you specify to the compiler that you wish to compile to a
.cpp file). A practical upshot to this method of code compilation is that it makes PRSE code
cross-compatible with all C++ libraries.

\subsection{Is PRSE the right choice for me?}
As PRSE is only in its earliest stages as a programming language, it does not have all the features
available that a given programmer might need. As such, if you require certain features in a
programming language that PRSE does not currently support, I recommend that you either look for
another language that supports the features you need, or (if you have the knowledge necessary to
work on this language) go to the GitLab page %TODO: Link gitlab here
and contribute there. I cannot guarantee I will still be maintaining this project since it was my
senior project for my bachelor's degree, but that would be the place to start if you wish to begin
contributing your own work.\linebreak

There is hope for those who still wish to work in this language despite its shortcomings: as a
temporary bandaid fix, I added a feature I like to call C++ injection mode. Simply surround a code
block like so:

\begin{lstlisting}
[CPPMODE] {
   // C++ code here
}
\end{lstlisting}

and whatever code you put in that block will not be translated from PRSE syntax, and instead will be
placed directly into PRSE's C++ buffer (which in turn is written to the .cpp file matching the name
of the .prse file), thus allowing for verbatim C++ programming.

\subsection{Running the PRSE Compiler}

If you have already installed the PRSE compiler---named \texttt{prsec} for `PRSE Compiler'---and
have it added to your PATH\footnote{see \hyperref[sec:prse-workspace-setup]{workspace setup} for
details}, then all you need to do to run it is enter the command\linebreak

\texttt{\$ prsec <filename>}\linebreak

in a terminal. As well, PRSE has a few command line arguments that you can pass to it. A few are
listed below in \autoref{tab:command-args}

\begin{table}[h]
   \centering
   \captionsetup{justification=centering}
   \caption{Command line arguments you can provide to \texttt{prsec}}
   \rule{0pt}{0.5cm} 
   \begin{tabularx}{400pt}{|X|X|}
      \hline
      Command            & Action           \\
      \texttt{-cpp}      & Compile to \texttt{.cpp} file, instead of directly to a binary. Useful for
                           something like turning your PRSE code into a C++ library. \\
      \texttt{-g}        & As with \texttt{g++}, retains source-level debugging/symbol information in the
                           outputted binary, for use with a debugging tool.\\
      \texttt{-lib}      & Link external library \\
      \hline
   \end{tabularx}
   \label{tab:command-args}
\end{table}

Some notes about the above:
\begin{itemize}
   \item since PRSE does not have a debugging tool at present, to debug a program compiled from PRSE
      code it is recommended that once you have created the binary file from your source, you should
      subsequently compile your PRSE code to C++ source using the \texttt{-cpp} command
\end{itemize}

\newpage

\section{Basic Program Structure}

A typical PRSE program will usually contain:

\begin{itemize}
\item Zero or more \texttt{use} statements which are followed by a string or list of strings, e.g. \texttt{"io", "math", "algorithm"}
\begin{itemize}
   \item These are used both for STL (standard template) libraries and third-party libraries, such as those created by other programmers and yourself
\end{itemize}
\item Variable declaration(s) and/or class declaration statement(s)
\item Function definition(s)
\end{itemize}

%$\left\{
%   \begin{tabularx}{\textwidth}{>{\centering\arraybackslash}X}
%   {\small From this definition, one may infer that an empty program is just as valid as a full program
%   complete with variables, functions, and class definitions. While this is certainly true,
%   such a program has no practical operation, and in fact will cause a warning to be printed to
%   the terminal.}
%   \end{tabularx}
%\right\}$\linebreak

\subsection{The Main Function}

A complete program written using PRSE needs a single \texttt{main} function to
run. Like all functions, this \texttt{main} function can return any primitive data type (see
\hyperref[sec:primitives]{primitives} for more information).\linebreak

A basic standard main function might look like this:\linebreak

\begin{lstlisting}
function main(ac: int, av: string[]){
   
}
\end{lstlisting}

Main Function Arguments \linebreak

\texttt{ac: int} declares a function argument named \texttt{ac} with primitive type \texttt{int}.
Similarly, \texttt{av: string[]} declares an argument named \texttt{av} with array type \texttt{string}.
\texttt{ac} can be used in the function to find the number of arguments passed to the program when it is run,
and likewise \texttt{av} can be used to obtain the \texttt{string} values of each argument.

\subsection{Common Compilation Errors}

As a programmer who is learning a new language, you are bound to encounter compilation errors. Here
are a few you might run into, and their codenames

\begin{table}[h]
   \centering
   \begin{tabularx}{\textwidth}{|X|X|X|}
      \hline
      \thead{Error codename} & \thead{Error} & \thead{How to Fix} \\ \hline
      Derby & Variable was not assigned as soon as it was initialized & Assign a variable on the same line that you create it \\ \hline
      Fedora & Infinite loop & Don't use infinite loops. \\ \hline
   \end{tabularx}
\end{table}

\newpage

\section{Basic Data Types}
\subsection{Primitives}
\label{sec:primitives}

PRSE supports most of the same primitive data types that C++ does, save for floating point numbers.
Doubles are supported in place of floating point numbers for the sake of simplicity in programming
the compiler. Refer to \autoref{tab:availablePrimitives} for basic data types that can be used
without additional libraries.\linebreak

\begin{table}[h]
\centering
   \caption{Primitive data types}
   \begin{tabularx}{400pt}{|X|X|X|}
      \hline
      \thead{Data type} & \thead{Supported formats} & \thead{Example(s)}     \\ \hline      
      Integer           & $ x \in \Z $              & 10, 12, -9, 8          \\ \hline
      Boolean           & $ x \in {true, false} $   & \it{true}, \it{false}  \\ \hline
      Character         & All ASCII characters      & A, G, f, \%, *         \\ \hline
      Double            & $ x \in \R $              & 12.45, 6.77777, 2.43   \\ \hline
   \end{tabularx}
   \label{tab:availablePrimitives}
\end{table}

\subsection{Enumerations}

Use the following syntax for \texttt{enum} types

\begin{lstlisting}
// <identifier> is a placeholder for the name you might give this enum. For instance, you might call it Numbers.
enum <identifier> {
   one,
   two,
   three,
   // etc...
}
\end{lstlisting}

Enums are, like in C++, their own data type, so it follows that if you wish to assign a variable to
a value of an enum you create, you must make sure that the variable you assign that value to is of
type <identifier>. For instance

\begin{lstlisting}
var foo: <identifier> = one;
\end{lstlisting}

Is a valid assignment operation, as is

\begin{lstlisting}
var foo[]: <identifier> = { one, three, four, /* etc... */ };
\end{lstlisting}

\newpage

\section{Flow Control}

\subsection{Conditionals}

If you're familiar with any C-like language, then you already know how to program an if-statement in
PRSE. However, if this is your first rodeo, here's what to expect

\begin{lstlisting}
if (/* Some condition, e.g. a >= b */){
   // Execute code
}
\end{lstlisting}

For a more concrete example, suppose we have the following code

\begin{lstlisting}
let foo: int = 25;
let bar: bool = false;

if (foo > 4 && bar == true){
   foo = 2;
}
\end{lstlisting}

Then the above if-statement will {\em not} execute because \texttt{bar} is false.\linebreak

In addition, we can also use \texttt{else if} and \texttt{else} clauses in a PRSE program to execute
code depending on how the conditions change:

\begin{lstlisting}
if (/* Conditions */){

} else if (/* Other conditions */) {

} else {
   // If all other conditions fail, execute this code.
}
\end{lstlisting}

\subsection{Loops}
\label{sec:flowcontrol-loops}

Loops in PRSE use the same syntax as C++, with a few bonus syntax options thrown in.

\subsubsection{For loops}

A standard for-loop has the following syntax

\begin{lstlisting}
for (initialization; condition; increase) statement;
\end{lstlisting}

This type operates exactly the same way as it does in C++. The initialization area sets up the
iterator variable; the condition area compares the current value of that iterator to a specified end
condition; the increase area specifies how the iterator should be altered on each iteration of the
loop.\linebreak

PRSE also supports a python-style loop syntax

\begin{lstlisting}
for (iterator in range) statement;

// For instance...
for (var i: int in range:int(0, 10)) print("{}", i);
\end{lstlisting}

In this case, the iterator must be set up as is specified in the above example: \texttt{var i: int};
\texttt{i} may take on any valid identifier name. The second code block in the above example will
iterate over a range of integers from 0 to 10, exclusive\footnote{The value in the upper bound will
be excluded from the returned range}

\subsubsection{While loops}



\subsubsection{Do-while loops}


\subsubsection{Quick iteration}

Finally, PRSE also supports another kind of iteration over variables: R-style vectorization.\linebreak

Say you have an array of some data type\footnote{it doesn't matter what data type you're using this
feature on, so long as the operation you apply is valid for that data type. For instance, you can't
do a \texttt{+=} or \texttt{-=} operation on a \texttt{char}.} and you wish to do something to all values
within that array. Use the following syntax to do so

\begin{lstlisting}
foo += 2;
\end{lstlisting}

To clarify: \texttt{foo} is an array of any type to which 2 can be added. The \texttt{+=} indicates
that you, the programmer, want to add (or in the case of a string, append) 2 to the current value(s)
of \texttt{foo}. See \autoref{tab:supportedDataTypes-quickIteration} for all the datatypes that you can
apply quick iteration to.\linebreak

\begin{wraptable}{r}{6cm}
   \centering
   \captionsetup{justification=centering}
   \caption{Supported data types for quick iteration}
   \begin{tabular}{|c|}
      \hline
      \thead{Data type}                 \\ \hline      
      Integer Array (\texttt{int[]})    \\ \hline
      Double Array (\texttt{double[]})  \\ \hline
      String Array (\texttt{string[]})  \\ \hline
   \end{tabular}
   \label{tab:supportedDataTypes-quickIteration}
\end{wraptable}

This particular feature comes in handy for many cases where you need to do some operation on each
index of an array, since you don't need to bother using any \texttt{for} loops. You may also desire
to print the value(s) in an array. To do that, use this syntax

\begin{lstlisting}
print("{}\n", foo);
\end{lstlisting}

The disadvantage to this syntax is the inability to retreive the iterator \texttt{i} for
\texttt{foo}. In such a case, you would need to manually type a for-loop rather than employing quick
iteration.

\section{Built-in Functions and Operations}

PRSE has a variety of included functions to make your life as a programmer much easier. Let's start
with something Python has, but C++ seemingly lacks: ranges. Ranges in PRSE use similar syntax to
that of Python's ranges, with a small alteration

\begin{lstlisting}
var n[]: int = range:int(0, 10);
\end{lstlisting}

Because variable types are indicated with a colon followed by the type, ranges use a similar syntax
to avoid ambiguity. % I mean, this isn't a _bad_ explanation, but it could be better worded.
Ranges are exclusive by default, meaning that they count up to the upper bound - 1. In the above
example, array \texttt{n} will contain integers 0 to 9. For an inclusive range, prepend
\texttt{range} with \texttt{incl\_}, for inclusive.\linebreak



\section{Standard Template Libraries}

\subsection{IO}

\texttt{use "io"}\linebreak

The \texttt{io} STL is the default library for printing things to the terminal. The following
functions are available in the library:

\subsubsection{\texttt{print()}}

\texttt{print(message: string, ...)}\linebreak

\texttt{...} represents a list of 0 or more constants that can be written to \texttt{stdout}. Among
these are all primitive datatypes, as well as classes with a defined \texttt{outstream} % TODO: change the name for this.
function.

\end{document}
% Document end
